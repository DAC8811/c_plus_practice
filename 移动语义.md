### 左值与右值
左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束时就不再存在的临时对象。简单讲凡是能够取地址的可以称之为左值，反之称之为右值
### 左值引用
```C++
  int a = 10;
  int& refA = a;//此时refA即为a的左值引用，修改refA的值上也等同于修改了a的值
  int& b = 1;//错误，1属于右值，无法进行左值引用
```  
### 右值引用
```C++
  int&& a = 1; //实质上就是给不具名(匿名)变量取了个别名
  int && c = b; //错误 不能将一个左值复制给一个右值引用
  class A
  {
  public:
    int a;
  };
  A getTemp()
  {
      return A();
  }
  A && a = getTemp();   //正确，getTemp()的返回值是右值（临时变量）
```
getTemp()返回的右值本来在表达式语句结束后生命周期就结束了，而通过右值引用，该右值生命期将与右值引用类型变量a的生命期一样    
本质上来说，该右值就已经变成了左值
### 可拷贝和可移动的概念
在面向对象中，有的类是可以拷贝的，可以调用拷贝构造函数   
有些类的对象或资源是独一无二的，比如IO、std::unique_ptr等。他们不可以复制，但是可以把资源交出所有权给新的对象，称为可以移动的    
在一些对象的构造时可以获取到已有的资源（如内存）而不需要通过拷贝，申请新的内存，这样移动而非拷贝将会大幅度提升性能
### 移动语义
移动构造函数，也就是移动语义，具体是将自己的指针指向其他变量的资源，然后将其他变量的指针修改为nullptr
右值本身将优先使用移动构造函数（因为右值的生命周期仅在其对应语句，一旦语句结束就会马上析构，因此不用白不用）
但左值默认使用拷贝构造函数（因为左值的生命周期较长，一般不能马上析构）
### std::move()方法
在C++11标准中，提供了std::move()方法将左值转换为右值，从而方便使用移动语义
```C++
str6 = std::move(str2)
```
使用时需要注意，在该语句结束后，str2对应资源的控制权被赋予了str6，但str2变量本身不会马上析构，必须等到其作用域结束后才会析构    
因此在该语句后调用str2中的数据可能导致错误
